# #数据类型

##  整形          ：char ,  int  ,  short ,   long,   longlong,

##所占的字节:      1        4           2           4               8  

## 浮点型        ： float  ， double

## 所占的字节：    4      ，        8

## 构造类型：

### > 数组类型

### >结构体类型     struct

### >指针       





# 整形在内存中的存储与读取

> **整形在内存中是按补码形式存储的**

### 原码     反码     补码

#### 存储数据

###### 原码：直接将二进制按照正数和负数进行转化；

###### 反码：原码的符号位（最高位）不变，剩下0、1序列取反

###### 补码：

######           对于无符号数和有符号正数：补码就是原码序列； 

######           对于有符号的正数   ：补码是原码取反加1；

为什么要有补码？

> 因为在计算机中，CPU只有加法器，使用补码可以将符号位的数值统一处理

##### 概念

###### 大端：数据的低位保存在内存的高地址中，数据的高位保存在内存的低地址中；

###### 小端：数据的地位保存在内存的低地址中，数据的高位保存在内存的高低之中：







#### 读取数据

######先看数据类型，然后进行保存



#### 总结

1、存的时候不考虑类型，取得时候考虑类型

2、在读取数据的时候，可能会发生整形提升，比如   

```
{
//此处就发生了整形提升
char  a=-1;
//1 的 二进制序列为  ：   1000 0001（原码）  在内存中存为 ：  1111 1111
printf("%d\n",a);
//  在读数据时发生整形提升
//整形提升时添加比特位根据原生类型添加的
  1111 1111 1111 1111 1111 1111 1111 1111
  所以输出数据为-1
}
```



例子2

```
int main()
{
	unsigned int i;
	for (i = 9; i >= 0; i--)
	{
		printf("%u\n", i);
	}
	return 0;
}
```

上面这个例子是死循环因为unsigned int的范围是0~2^32, 当循环进行到0时因为满足循环条件，所以0-1，得到的数是2^32,从2^32到0一次输出，再到0-1，又变为 2^32 再次循环；

列子3

```
int main()
{
	short num = 32767;
	short int a = num + 1;
	printf("%d\n", a);
	return 0;
}
//输出  -32768
```



## 浮点数据的存储

> 首先注意一个点： 强制类型转化和转化
>
> 强制类型转化：是更改看待数据的方式



```
int main()
{
	int n = 9;
	//原码/补码 0000 0000 0000 0000 0000 0000 0000 1001
	float *p = (float*)&n;
	//0 00000000 00000000000000000001001
	//0   0-127  00000000000000000001001
	//2^-127 无限接近为0；
	//所以*p的值为0；
	printf("n的值为：%d\n", n);
	printf("*p : %f\n", *p);
	*p = 9.0;
	//如果将*p直接赋值为9.0；
	//0 10000000 10010000000000000000000
	printf("n: %d\n", n);
	//输出时直接按原码输出  特别大的一个数
	printf("*p : %f\n", *p);
	//9.0
	return 0;
 }

```

![](C:\Users\admin\Desktop\TIM截图20181104195445.jpg)



> 强转二进制序列没有改变，只是读取的方式改变了



#### 公式

##### 二进制浮点数可以表示为

> (-1)^s**M*  *2^E （科学技术法）



![](C:\Users\admin\Desktop\TIM截图20181105194341.jpg)



> 浮点数不能和0，比较

但我们知道科学计数法是可以有负数的，所以我们存入内存的E还要加上 +127这个中间数

所以E范围为   -127~128,  又2^-127无限接近于0；或者-2^128所以浮点数不能与0 比较大小

 在科学计数法里（1<M<2）,但在内存存取时省略1，值存精度部分； 且进度部分从左向有存；

















